①：用户添加商品到购物车，结算提交订单（没登录先登录）
②：生成预订单（对用户不可见）
③：扣减库存，扣减账户余额（分布式事务，可选的方案有：seata分布式事务，发生异常mq消息补偿 （它俩追求强一致性，要么回滚要么成功））
④：将订单状态改为可见状态，根据订单号和WX第三方接口生成支付的URL
⑤：前端根据URL生成支付二维码
⑥：前端定时扫描订单支付接口（该接口远程调用WX第三方接口根据订单号查询支付状态）
⑦：支付成功，修改订单支付状态，添加商品信息，添加积分（分布式事务，可选的方案有：mq+定时任务（追求最终一致性，将消息存放到数据库中，定时任务扫描到后，通过mq发送消息，追求最终成功））
如何判断订单是否按时支付：一：通过定时任务，查询1小时前所有支付状态为未支付的订单。
		           二：创建订单后，发送MQ延时消息，消费方1小时后接收到该消息，查看支付状态。
⑧：订单没有按时支付，则将扣减了的库存和账户余额进行补偿（延时消息）
  	
*为什么分布式事务所追求的东西不一样：
第一个分布式事务，在创建订单阶段失败了就让他重新创建订单，没必要非得创建成功
第二个分布式事务，因为用户已经生成了订单且支付成功了，那么要追求最终一致性，一定要把执行成功
第三个分布式事务，用户没有支付订单，那么要追求最终一致性，将原来扣减了的东西一定要回退回去

*分布式事务的策略
当远程调用的是不重要的方法时，可以为其配置降级方法，发生了错误执行降级方法将内容存入数据库完了做补偿不影响正常业务的执行。（发生错误调用降级方法不会触发分布式事务）
当远程调用的是重要的方法时，不需要为其配置降级方法，发生了错误直接分布式事务回滚即可。

       