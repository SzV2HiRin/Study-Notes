***final关键字：
final修饰类，表示该类不能被继承
final修饰方法，表示该方法不能被重写
final修饰变量，如果是基本类型 则表示不能重新赋值
	       如果是引用类型 则不能指向其他对象（该变量对应的引用地址不能变，但引用对应的内容是可变的）

***finally:
现在有return语句，还会执行finally中的代码吗？
会执行的，先执行return再执行finally里的代码。如果try和finally里面都有return，那么最终返回的是finally里的return语句。
如果try中执行exit（）则直接退出不会执行finally中的语句

***构造函数不能被重写，但可以重载

***数据库中存放金额类型的数据，可以使用decimal类型，有着比double更准的精度

***JAVA中的基本类型：int(4个字节)，short(2个字节)，long(8个字节)，byte(1个字节)，boolean(1个字节)，char(2个字节)，float(4个字节)，double(8个字节)
int类型所能表示的大小是：-2的32次方到2的32次方-1

***Switch支持的数据类型：int，short，byte，char，String

***数组构建的过程
首先在栈中开辟一块空间，将数组引用指向这块空间，然后在堆里分配连续内存，栈中那块空间的引用再指向堆

***数组为什么查找块
因为它在堆中的内存是连续的，所以说它可以使用索引来查找

***局部变量和全局变量可以重名吗
可以的，调用的话this.变量名调用的是全局变量，直接变量名调用的是局部变量

***ClassNotFoundException和NoClassDefFoundError的区别：
ClassNotFoundException是在我们用类加载器加载某一类时，如果没有在classPath下找到，那么就抛出ClassNotFoundException异常(序列化ObjectOutPutStream.writeObject()会抛出此异常)
NoClassDefFoundError是指当一个类编译通过，但是在运行过程中找不到了，那么就出现NoClassDefFoundError错误（class文件被删除）
ClassNotFoundException是加载类的时候抛出的，NoClassDefFoundError是编译后找不到类出现的错误

***面向对象的特征：
抽象：将一些共有属性，方法提取出来构建成类
封装：把一个对象的一些属性私有化，不允许外部对象直接访问对象的内部信息，但可以提供一些方法来进行操作（private，set/get）
继承：子类可以继承父类，同时享有父类的所有属性和方法，在父类的基础上做扩展
多态：表示一个对象可以有多种形态，一个父类有多个子类，实例化时子类指向父类

**调用Arrays.asList("a","b")变成集合后，不能调用add、remove方法会抛出异常，因为转换后，这个集合存的内容其实还是数组的内容

**开发遇到的问题：SpringBoot项目在使用了ComponentScan注解扫描其他项目组件后，springboot就不会扫描本项目的组件了，因此也要添加ComponentScan扫描本项目下的组件

**开发遇到的问题2：远程调用场景，A服务调用B服务
	                B服务运行发生异常或手动抛出RunTimeException，A服务会感知到（try/catch到异常）
		B服务抛出自定义的全局MyException，A服务不会感知到(try/catch不到异常)，因此我们可以在Transactional（设置rollbackFall=MyException.class）让A服务感知到
		（当设置了fallback降级方法后发生异常会走降级方法，A服务不会感知到，因此在分布式事务时，对于一些不重要的业务发生异常后可以在fallback中进行补偿不影响全局事务的提交）

**异常不回滚问题：当代码块添加了try/catch后，异常不会回滚
	              解决方法：①：去掉try/catch
		               ②：在catch中手动throw异常

***后端参数校验：有些业务情况下，前端检查完参数后，后端也需要检查参数
	           使用 Spring Boot 程序的话只需要spring-boot-starter-web 就够了，它的子依赖包含了我们所需要的东西。
	           可以使用JSR校验或者Hibernate Validator校验，在类上添加@Validated注解提醒spring去校验方法参数
	           https://github.com/Snailclimb/springboot-guide/blob/master/docs/advanced/spring-bean-validation.md

***CAP理论：C（Consistency）一致性，A（Availability）可用性，P（Partition tolerance）分区容错性，我们一般只能满足其中的两个，无法同时满足三个，但我们分布式架构必须要保证P
     BASE理论：基于CAP所衍生出来的理论，BA：基本可用（追求CP），S：软状态，E最终一致性（追求AP）

***Nacos服务注册到注册中心的原理
其实nacos，zookeeper......都是一个WEB服务，它会对外提供很多接口：注册实例，拉取实例，发送心跳等。。。
我们服务引入注册中心的pom包，pom包中其实就封装好了很多访问注册中心接口的URL，根据URL再配合配置文件中配置的注册中心地址，可以自动调用注册中心的接口将信息发送过去
A服务远程调用B服务，它会先到注册中心中根据服务名拉取B服务的所有实例对应的IP和端口，缓存到本地
		  然后通过Feign或Ribbon的方式进行负载均衡调用，
		  当B服务又添加一个实例或下线一个实例后会发送心跳通知注册中心
		  Ribbon和Fegin底层会有一个定时任务，会去注册中心中获取B服务最新的实例信息，覆盖掉A服务本地的缓存

***Eureka服务注册到注册中心的原理
Eureka注册中心，分为多级缓存：只读缓存，只写缓存，和Eureka实际存放数据的内存
服务提供方根据pom中Eureaka包中的接口和配置文件中配置的Eureaka的URL将信息注册到Eureka内存中，写的时候会加锁（为了防止要写的信息还没写完就被读取出去了，发生脏读情况）
最后将数据同步到只写缓存当中。
A服务远程调用B服务，它会去注册中心的只读缓存获取B服务的信息，不在则会去只写缓存获取，若还不在则会去Eureka内存中获取
		  然后通过Feign或Ribbon的方式进行负载均衡调用，
		  当B服务又添加一个实例或下线一个实例后会发送心跳通知注册中心
		  更新Eureka内存中的信息，过期掉只写缓存，每隔30s将只写缓存的内容同步到只读缓存（这就是eureka的自我保护机制，服务断开不会第一时间将服务信息给剔除）
						     每隔180s将只写缓存失效，下次有服务来拉取信息时，又会从内存中获取最新数据了，且会填充各个缓存 

服务调用方获取注册信息时，会到只读缓存中获取，若没有则去只写缓存获取，若还是没有则会去Eureka内存中获取

***Eureka和Nacos的区别
Eureka是AP最终一致性，Nacos（集群使用Raft协议）可以在AP和CP之间来回切换，Zookeeper是CP
Eureka有多级缓存，Nacos是本地缓存，Nacos实时性比Eureka好很多
Nacos支持的并发比Eureka高，Eureka通过加锁来解决读写冲突，Nacos是通过CopyOnWrite写时复制的思想来解决读写冲突
						  （这样在新写数据的时候会拷贝出一份新的数据进行追加，如果用户来读取数据则会读取旧的数据，防止了脏读的发生）

***Feign的原理
Feign远程调用：使用Feign进行调用时会生成一个动态代理对象，根据feign接口配置的服务名，调用Ribbon根据服务名负载均衡一个实例得到ip和port，再根据方法路径来拼装成一个完整的URL，然后进行http远程调用。

***脑裂问题
注册中心在集群架构下且是主从结构，发生分区，导致出现两个主节点，其中一个主节点最终会恢复成从节点这个过程中会丢失掉数据，这就发生了脑裂情况
Eureka没有脑裂问题，因为它是AP架构，集群时候各个节点都是对等关系。
Zookeeper也不会出现脑裂问题，虽然它是CP架构，集群时各个节点是主从关系，但它有ZAB协议的支持（即写数据时，50%以上的节点写数据成功那么才算写入成功）
解决方式：可以增加节点冗余心跳线的方式来解决脑裂问题。

***数据库有单热点经常更新的数据，怎么解决？
1：可以采用redis缓存的方式来缓存热点数据，但可能会出现缓存超时的情况，也会出现数据一致性的问题，因为大量修改请求进来，有缓存的话需要保证缓存和数据库的一致性，我们也不能加锁因为数据库是通过
行锁来保证并发安全的，加锁会降低程序的性能。
2：采用分而治之的思想，将热点数据拆分成多条数据，然后去更新多条数据最后再合并成一条。（如果不拆分，10个请求进来，需要加10次行锁是一个串行操作，如果拆分的话，10个请求进来，也需要加10次行锁
但是变成了并行操作，这样效率大大提高）。

***String
当new一个String对象时，（当常量池中没有对应字符时）它会在堆和常量池中都创建一个对象（有对应字符，则只会在堆中创建一个对象），如果是直接赋值的方式则只会在常量池创建一个对象
String底层的是被final修饰的char数组，代表着String对象是不可变的同时也可以确保String的线程安全。
							              （由于地址不可变，那么就保证了多线程下的数据一致性）
***JAVA和C++的区别
它俩都是面向对象的，都支持继承，多态，封装特性
JAVA不提供指针，C++有指针
JAVA是单继承，C++是多继承
JAVA有内存自动管理机制，无需程序员手动释放内存

***&和&&的区别
&和&&都是逻辑与运算，左右两边都为true则整体为true，但是&&是短路运算，只要左边不满足则直接返回false不执行右边的，&无论左边结果都会执行右边

***内部类
JAVA中共有四种内部类：成员内部类，局部内部类，匿名内部类，静态内部类
静态内部类：定义在类中被static修饰，静态内部类可以访问外部类的所有静态变量，不可以访问非静态变量
成员内部类：定义在类中，什么修饰符都不加就是成员内部类，成员内部嘞可以访问外部类的所有变量和方法，包括静态非静态
局部内部类：定义在方法中的内部类，就称为局部内部类
匿名内部类：比较常见，匿名内部类没有名字，一般出现于，我们直接new一个接口或抽象类时直接重写它的方法即可。

***值传递，引用传递
值传递：一般指的是基本类型作为形参，传递的是该变量的一个副本，改变副本不会影响原变量
引用传递：一般指的是引用类型作位形参，传递的是该变量的地址，所以对该变量做操作会影响原变量