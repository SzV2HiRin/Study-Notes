dubbo执行过程：
①：服务提供方和服务调用方都将自己注册到zookeeper注册中心
②：服务调用方从zookeeper中拉取服务提供方的信息 ，采用负载均衡选择其中一台机器
       调用方开始调用，将要调用的方法及参数序列化为可在网络中进行传输的消息体，然后通过TCP将其发送给提供者
③：提供者接收到消息，进行反序列化，然后在本地调用对应的方法
       将方法的返回值也序列化为可在网络中传输的消息体，然后通过TCP将其发送给调用者
④：调用者反序列化消息获取返回值

序列化的方式：Serializable（性能差），hessian（dubbo默认的序列化协议），webService（Soap文本），http（json）

dubbo和SpringCloud的区别：
dubbo和springCloud相比效率稍微好一点，它远程调用使用的是高效率的RPC框架，SpringCloud使用的是http
SpringCloud集成很多功能，相比dubbo更方便一些

自己设计一个RPC框架：
①：首先要设计一个注册中心，让它有服务注册和服务拉取的功能，可以定义成map结构，key存放服务名，value存放服务信息
②：设计一个负载均衡的功能，提供不同的策略，保证某一服务是集群时，能选择集群中的一台机器做调用
③：要为提供方和调用方设计动态代理，RPC框架的核心逻辑都是在代理对象中实现的
④：设计一种序列化（hessian）和反序列化的方式来封装消息体，设计一种通信方式（netty）来传输消息体
⑤：服务注册方要定时向注册中心发送心跳，保证可用性
⑥：设计一种扩展方式，要保证注册中心的高可用，搭建集群
⑦：将服务的注册信息进行持久化，保证注册信息不丢失

负载均衡的策略：
①：随机策略：每次随机选择一个服务提供方进行调用
②：轮询策略：获取到服务提供方的集群列表（提供方信息存放在Directory，通过Cluster来封装这个目录）后，根据访问次数对机器数取余，来得到要调用的机器号，进行调用
③：权重：为每一个服务的提供方设置一个权重，eg：机器1权重是7，机器2权重是3，这是就可以生成一个1-10的随机数（机器1在1-7，机器2在8-10），让随机数-7，如果>0则选择机器2，<=0则选择机器1
④：空闲策略：选择现在被调用次数最少的机器调用，所有机器活跃数初始都为0每被调用一次活跃数+1，当活跃数相同时则通过比较权重（选择权重大的）来选择机器。
⑤：一致性Hash算法：将hash值的区间设为0-2^32-1，并且是个循环的圆环状，将服务器的IP等信息生成一个hash值，将这个hash值映射到圆环上作为一个结点，然后通过key来获取节点（顺时针查找第一个
大于等于这个key的hash值所对应的节点），然后就获取到要调用的机器了，Dubbo中默认搞了160个虚拟节点